/**
 * Chat Store
 *
 * Manages chat interface state including message history, loading states, and AI communication.
 * Integrates with AIService via IPC for sending messages and receiving responses.
 *
 * Features:
 * - Message history management
 * - Streaming and non-streaming message support
 * - Loading and error states
 * - Integration with Feature 2.1 AIService
 * - Unique message IDs with timestamps
 * - Conversation persistence (Wave 2.2.4)
 * - Auto-save after AI responses
 */

import { create } from 'zustand';
import type { Conversation } from '@shared/types';
import { debounce } from '@renderer/utils/debounce';

/**
 * Message roles
 */
export type MessageRole = 'user' | 'assistant';

/**
 * Message status
 */
export type MessageStatus = 'sending' | 'streaming' | 'complete' | 'error';

/**
 * Represents a single chat message
 */
export interface ChatMessage {
  /** Unique message identifier */
  id: string;
  /** Message role (user or assistant) */
  role: MessageRole;
  /** Message content */
  content: string;
  /** Message timestamp */
  timestamp: Date;
  /** Message status */
  status: MessageStatus;
  /** Error message if status is 'error' */
  error?: string;
}

/**
 * Chat state interface
 */
interface ChatState {
  // State
  /** Current conversation ID */
  conversationId: string;
  /** Array of chat messages */
  messages: ChatMessage[];
  /** Currently streaming message ID */
  streamingMessageId: string | null;
  /** Loading state during AI initialization */
  isInitializing: boolean;
  /** Is AI service initialized */
  isInitialized: boolean;
  /** Error message from failed operations */
  error: string | null;

  // Actions
  /** Initialize AI service */
  initializeAI: () => Promise<void>;
  /** Send a message to AI */
  sendMessage: (content: string) => Promise<void>;
  /** Cancel current streaming request */
  cancelStreaming: () => Promise<void>;
  /** Save conversation to storage (debounced) */
  saveConversation: () => void;
  /** Load conversation by ID */
  loadConversation: (conversationId: string) => Promise<void>;
  /** Start new conversation */
  newConversation: () => void;
  /** Clear all messages */
  clearMessages: () => void;
  /** Clear error state */
  clearError: () => void;
  /** Reset store to initial state */
  reset: () => void;
}

/**
 * Generate unique message ID
 */
const generateMessageId = (): string => {
  return `msg-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
};

/**
 * Generate unique conversation ID
 */
const generateConversationId = (): string => {
  return `conv-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
};

/**
 * Internal save implementation (not debounced)
 */
const doSaveConversation = async (
  conversationId: string,
  messages: ChatMessage[]
): Promise<void> => {
  try {
    const conversation: Conversation = {
      id: conversationId,
      title: 'New Conversation', // Will be auto-generated by storage service
      provider: 'anthropic', // Default - will be updated when settings are implemented
      model: 'claude-sonnet-4-5', // Default - will be updated when settings are implemented
      messages: messages.map((msg) => ({
        id: msg.id,
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp,
        status: msg.status,
        error: msg.error,
      })),
      createdAt: new Date(),
      lastModified: new Date(),
    };

    const result = await window.electronAPI.conversation.save(conversation);

    if (!result.success) {
      console.error('Failed to save conversation:', result.error);
    }
  } catch (error) {
    console.error('Failed to save conversation:', error);
  }
};

/**
 * Chat store for managing message history and AI communication
 */
export const useChatStore = create<ChatState>((set, get) => {
  // Create debounced save function (max 1 call per second)
  const debouncedSave = debounce((conversationId: string, messages: ChatMessage[]) => {
    void doSaveConversation(conversationId, messages);
  }, 1000);

  return {
    // Initial state
    conversationId: generateConversationId(),
    messages: [],
    streamingMessageId: null,
    isInitializing: false,
    isInitialized: false,
    error: null,

    /**
     * Initialize AI service
     * Must be called before sending messages
     */
    initializeAI: async () => {
      const { isInitialized } = get();

      // Already initialized, skip
      if (isInitialized) {
        return;
      }

      set({ isInitializing: true, error: null });

      try {
        const result = await window.electronAPI.ai.initialize();

        if (!result.success) {
          set({
            isInitializing: false,
            isInitialized: false,
            error: result.error.message || 'Failed to initialize AI service',
          });
          return;
        }

        set({
          isInitializing: false,
          isInitialized: true,
          error: null,
        });
      } catch (err) {
        set({
          isInitializing: false,
          isInitialized: false,
          error: err instanceof Error ? err.message : 'Failed to initialize AI service',
        });
      }
    },

    /**
     * Send a message to AI
     * Creates user message immediately and streams AI response
     *
     * @param content - Message content to send
     */
    sendMessage: async (content: string) => {
      const { messages, isInitialized } = get();

      // Validate AI is initialized
      if (!isInitialized) {
        set({ error: 'AI service not initialized. Please wait...' });
        return;
      }

      // Validate content
      if (!content.trim()) {
        set({ error: 'Message cannot be empty' });
        return;
      }

      // Create user message
      const userMessage: ChatMessage = {
        id: generateMessageId(),
        role: 'user',
        content: content.trim(),
        timestamp: new Date(),
        status: 'complete',
      };

      // Create placeholder assistant message
      const assistantMessage: ChatMessage = {
        id: generateMessageId(),
        role: 'assistant',
        content: '',
        timestamp: new Date(),
        status: 'streaming',
      };

      // Add both messages to state
      set({
        messages: [...messages, userMessage, assistantMessage],
        streamingMessageId: assistantMessage.id,
        error: null,
      });

      // Set up streaming event listeners
      let fullResponse = '';

      const cleanupListeners: Array<() => void> = [];

      const onToken = (token: string) => {
        fullResponse += token;
        const currentMessages = get().messages;
        const updatedMessages = currentMessages.map((msg) =>
          msg.id === assistantMessage.id
            ? {
                ...msg,
                content: fullResponse,
                status: 'streaming' as MessageStatus,
              }
            : msg
        );
        set({ messages: updatedMessages });
      };

      const onComplete = (response: string) => {
        fullResponse = response;
        const currentMessages = get().messages;
        const updatedMessages = currentMessages.map((msg) =>
          msg.id === assistantMessage.id
            ? {
                ...msg,
                content: fullResponse,
                status: 'complete' as MessageStatus,
              }
            : msg
        );
        set({
          messages: updatedMessages,
          streamingMessageId: null,
        });

        // Auto-save conversation after AI response completes (Wave 2.2.4)
        const { conversationId } = get();
        debouncedSave(conversationId, updatedMessages);

        // Cleanup listeners
        cleanupListeners.forEach((cleanup) => cleanup());
      };

      const onError = (errorMessage: string) => {
        const currentMessages = get().messages;
        const updatedMessages = currentMessages.map((msg) =>
          msg.id === assistantMessage.id
            ? {
                ...msg,
                status: 'error' as MessageStatus,
                error: errorMessage,
              }
            : msg
        );
        set({
          messages: updatedMessages,
          streamingMessageId: null,
          error: errorMessage,
        });

        // Cleanup listeners
        cleanupListeners.forEach((cleanup) => cleanup());
      };

      // Register event listeners
      cleanupListeners.push(window.electronAPI.ai.onStreamToken(onToken));
      cleanupListeners.push(window.electronAPI.ai.onStreamComplete(onComplete));
      cleanupListeners.push(window.electronAPI.ai.onStreamError(onError));

      try {
        // Start streaming
        const result = await window.electronAPI.ai.streamMessage(content.trim());

        if (!result.success) {
          onError(result.error.message || 'Failed to send message');
        }
      } catch (err) {
        onError(err instanceof Error ? err.message : 'Failed to send message');
      }
    },

    /**
     * Cancel current streaming request
     */
    cancelStreaming: async () => {
      const { streamingMessageId, messages } = get();

      if (!streamingMessageId) {
        return;
      }

      try {
        await window.electronAPI.ai.cancel();

        // Mark streaming message as complete (partial)
        const updatedMessages = messages.map((msg) =>
          msg.id === streamingMessageId
            ? {
                ...msg,
                status: 'complete' as MessageStatus,
                content: msg.content + ' [cancelled]',
              }
            : msg
        );

        set({
          messages: updatedMessages,
          streamingMessageId: null,
        });
      } catch (err) {
        set({
          error: err instanceof Error ? err.message : 'Failed to cancel request',
        });
      }
    },

    /**
     * Save conversation to storage (debounced)
     * Wave 2.2.4: Manual save trigger
     */
    saveConversation: () => {
      const { conversationId, messages } = get();
      debouncedSave(conversationId, messages);
    },

    /**
     * Load conversation by ID
     * Wave 2.2.4: Load existing conversation
     */
    loadConversation: async (conversationId: string) => {
      try {
        const result = await window.electronAPI.conversation.load(conversationId);

        if (!result.success) {
          set({
            error: result.error.message || 'Failed to load conversation',
          });
          return;
        }

        // Convert conversation messages to chat messages
        const loadedMessages: ChatMessage[] = result.data.messages.map((msg) => ({
          id: msg.id,
          role: msg.role,
          content: msg.content,
          timestamp: new Date(msg.timestamp),
          status: msg.status,
          error: msg.error,
        }));

        set({
          conversationId: result.data.id,
          messages: loadedMessages,
          error: null,
        });
      } catch (error) {
        set({
          error: error instanceof Error ? error.message : 'Failed to load conversation',
        });
      }
    },

    /**
     * Start new conversation
     * Wave 2.2.4: Clear current conversation and start fresh
     */
    newConversation: () => {
      // Save current conversation before clearing
      const { conversationId, messages } = get();
      if (messages.length > 0) {
        void doSaveConversation(conversationId, messages);
      }

      // Start new conversation
      set({
        conversationId: generateConversationId(),
        messages: [],
        streamingMessageId: null,
        error: null,
      });
    },

    /**
     * Clear all messages
     */
    clearMessages: () => {
      set({
        messages: [],
        streamingMessageId: null,
        error: null,
      });
    },

    /**
     * Clear error state
     */
    clearError: () => {
      set({ error: null });
    },

    /**
     * Reset store to initial state
     */
    reset: () => {
      set({
        conversationId: generateConversationId(),
        messages: [],
        streamingMessageId: null,
        isInitializing: false,
        isInitialized: false,
        error: null,
      });
    },
  };
});
